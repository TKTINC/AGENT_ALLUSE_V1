#!/usr/bin/env python3
"""
WS3-P4: Comprehensive Testing and Validation
Security Vulnerability Tests

This module implements security tests for the account management system,
validating protection against common security vulnerabilities.

Author: Manus AI
Date: June 17, 2025
Version: 1.0
"""

import sys
import os
import json
import time
import random
import re
from datetime import datetime, timedelta
import uuid
import threading
import requests
from concurrent.futures import ThreadPoolExecutor
from typing import Dict, List, Any, Tuple

# Add project root to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))))

# Import account management test framework
from tests.account_management.account_management_test_framework import (
    AccountManagementTestFramework, TestCategory
)

# Import account management components
from src.account_management.models.account_models import (
    Account, GenerationAccount, RevenueAccount, CompoundingAccount,
    AccountStatus, AccountType, create_account
)
from src.account_management.database.account_database import AccountDatabase
from src.account_management.api.account_operations_api import AccountOperationsAPI
from src.account_management.security.security_framework import SecurityFramework

class SecurityVulnerabilityTests:
    """
    Security vulnerability tests for the account management system.
    
    This class implements tests for:
    - Authentication Vulnerabilities
    - Authorization Vulnerabilities
    - Injection Attacks
    - Cross-Site Scripting (XSS) Protection
    - CSRF Protection
    """
    
    def __init__(self):
        self.framework = AccountManagementTestFramework()
        
        # Initialize components
        self.db = AccountDatabase(":memory:")
        self.security = SecurityFramework(self.db)
        self.api = AccountOperationsAPI(self.db, self.security)
        
        # Create test users
        self.test_user_id = "test_user_123"
        self.security.create_user(self.test_user_id, "Test User", "test@example.com", "password123")
        
        self.admin_user_id = "admin_user_456"
        self.security.create_user(self.admin_user_id, "Admin User", "admin@example.com", "adminpass123")
        self.security.assign_role(self.admin_user_id, "admin")
        
        # Generate auth tokens
        self.user_token = self.security.generate_auth_token(self.test_user_id)
        self.admin_token = self.security.generate_auth_token(self.admin_user_id)
        
        # Create test account
        account_data = {
            "name": "Security Test Account",
            "account_type": AccountType.GENERATION,
            "initial_balance": 100000.0,
            "owner_id": self.test_user_id
        }
        
        create_result = self.api.create_account(self.user_token, account_data)
        self.test_account_id = create_result["account_id"]
    
    def test_authentication_vulnerability(self):
        """Test authentication vulnerabilities"""
        try:
            security_tests = []
            
            # Test 1: Invalid token
            invalid_token = "invalid_token_123"
            result = self.api.get_account(invalid_token, self.test_account_id)
            security_tests.append(result["success"] is False)
            security_tests.append("authentication" in result["error"].lower())
            
            # Test 2: Expired token
            expired_token = self.security.generate_auth_token(self.test_user_id, expires_in=-3600)  # Expired 1 hour ago
            result = self.api.get_account(expired_token, self.test_account_id)
            security_tests.append(result["success"] is False)
            security_tests.append("expired" in result["error"].lower())
            
            # Test 3: Tampered token
            tampered_token = self.user_token[:-5] + "12345"  # Change last 5 characters
            result = self.api.get_account(tampered_token, self.test_account_id)
            security_tests.append(result["success"] is False)
            
            # Test 4: Brute force protection
            # Attempt multiple failed logins
            for i in range(10):
                self.security.authenticate_user("test@example.com", f"wrong_password_{i}")
            
            # Check if account is locked
            login_result = self.security.authenticate_user("test@example.com", "password123")
            security_tests.append(login_result["success"] is False)
            security_tests.append("locked" in login_result["error"].lower())
            
            # Reset account lock for further tests
            self.security.reset_login_attempts("test@example.com")
            
            # Test 5: Session fixation protection
            # Generate token
            token1 = self.security.generate_auth_token(self.test_user_id)
            
            # Simulate user re-authentication
            login_result = self.security.authenticate_user("test@example.com", "password123")
            token2 = login_result["token"]
            
            # Old token should be invalidated
            result = self.api.get_account(token1, self.test_account_id)
            security_tests.append(result["success"] is False)
            
            # New token should work
            result = self.api.get_account(token2, self.test_account_id)
            security_tests.append(result["success"] is True)
            
            # Calculate success
            success = all(security_tests)
            
            return {
                "success": success,
                "metrics": [
                    {"name": "authentication_security", "value": sum(security_tests), "target": len(security_tests), "threshold": len(security_tests), "passed": success}
                ],
                "security_results": security_tests
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def test_authorization_vulnerability(self):
        """Test authorization vulnerabilities"""
        try:
            security_tests = []
            
            # Create another user
            other_user_id = "other_user_789"
            self.security.create_user(other_user_id, "Other User", "other@example.com", "otherpass123")
            other_token = self.security.generate_auth_token(other_user_id)
            
            # Create account for other user
            other_account_data = {
                "name": "Other User Account",
                "account_type": AccountType.GENERATION,
                "initial_balance": 100000.0,
                "owner_id": other_user_id
            }
            
            other_result = self.api.create_account(other_token, other_account_data)
            other_account_id = other_result["account_id"]
            
            # Test 1: Horizontal privilege escalation
            # User tries to access other user's account
            result = self.api.get_account(self.user_token, other_account_id)
            security_tests.append(result["success"] is False)
            security_tests.append("authorization" in result["error"].lower())
            
            # Test 2: Vertical privilege escalation
            # Regular user tries to access admin endpoint
            result = self.api.get_all_accounts(self.user_token)
            security_tests.append(result["success"] is False)
            security_tests.append("permission" in result["error"].lower())
            
            # Test 3: Parameter tampering
            # Try to update other user's account
            update_data = {
                "name": "Hacked Account"
            }
            
            result = self.api.update_account(self.user_token, other_account_id, update_data)
            security_tests.append(result["success"] is False)
            
            # Test 4: Insecure direct object reference
            # Try to access account by guessing ID
            random_id = str(uuid.uuid4())
            result = self.api.get_account(self.user_token, random_id)
            security_tests.append(result["success"] is False)
            
            # Test 5: Role-based access control
            # Admin should be able to access any account
            admin_result = self.api.get_account(self.admin_token, other_account_id)
            security_tests.append(admin_result["success"] is True)
            
            # Admin should be able to access admin endpoints
            admin_result = self.api.get_all_accounts(self.admin_token)
            security_tests.append(admin_result["success"] is True)
            
            # Calculate success
            success = all(security_tests)
            
            return {
                "success": success,
                "metrics": [
                    {"name": "authorization_security", "value": sum(security_tests), "target": len(security_tests), "threshold": len(security_tests), "passed": success}
                ],
                "security_results": security_tests
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def test_injection_attack(self):
        """Test protection against injection attacks"""
        try:
            security_tests = []
            
            # Test 1: SQL Injection in account name
            sql_injection_data = {
                "name": "Injection Test' OR 1=1; --",
                "account_type": AccountType.GENERATION,
                "initial_balance": 100000.0,
                "owner_id": self.test_user_id
            }
            
            # This should succeed but not be vulnerable
            result = self.api.create_account(self.user_token, sql_injection_data)
            security_tests.append(result["success"] is True)
            
            # Verify no unauthorized access
            all_accounts = self.db.get_all_accounts()
            injection_success = False
            
            for account in all_accounts:
                if account.owner_id != self.test_user_id and account.name == sql_injection_data["name"]:
                    injection_success = True
                    break
            
            security_tests.append(injection_success is False)
            
            # Test 2: SQL Injection in transaction description
            transaction_data = {
                "amount": 1000.0,
                "transaction_type": "deposit",
                "description": "Injection Test'; DROP TABLE accounts; --"
            }
            
            result = self.api.add_transaction(self.user_token, self.test_account_id, transaction_data)
            security_tests.append(result["success"] is True)
            
            # Verify table still exists
            try:
                account = self.db.get_account_by_id(self.test_account_id)
                security_tests.append(account is not None)
            except Exception:
                security_tests.append(False)
            
            # Test 3: NoSQL Injection (if applicable)
            nosql_data = {
                "name": {"$ne": ""},  # NoSQL injection attempt
                "account_type": AccountType.GENERATION,
                "initial_balance": 100000.0,
                "owner_id": self.test_user_id
            }
            
            try:
                result = self.api.create_account(self.user_token, nosql_data)
                # Should either fail validation or sanitize the input
                if result["success"]:
                    account = self.db.get_account_by_id(result["account_id"])
                    security_tests.append(isinstance(account.name, str))
                else:
                    security_tests.append(True)
            except Exception:
                security_tests.append(True)  # Exception is acceptable for invalid input
            
            # Test 4: Command Injection
            cmd_injection_data = {
                "name": "Command Injection; rm -rf /; Test",
                "account_type": AccountType.GENERATION,
                "initial_balance": 100000.0,
                "owner_id": self.test_user_id
            }
            
            result = self.api.create_account(self.user_token, cmd_injection_data)
            security_tests.append(result["success"] is True)
            
            # Verify system is still operational
            try:
                account = self.db.get_account_by_id(result["account_id"])
                security_tests.append(account is not None)
            except Exception:
                security_tests.append(False)
            
            # Test 5: Path Traversal
            path_data = {
                "name": "../../../etc/passwd",
                "account_type": AccountType.GENERATION,
                "initial_balance": 100000.0,
                "owner_id": self.test_user_id
            }
            
            result = self.api.create_account(self.user_token, path_data)
            security_tests.append(result["success"] is True)
            
            # Verify no path traversal in export
            export_result = self.api.export_account_data(self.user_token, result["account_id"])
            security_tests.append(export_result["success"] is True)
            security_tests.append("passwd" not in export_result["file_path"])
            
            # Calculate success
            success = all(security_tests)
            
            return {
                "success": success,
                "metrics": [
                    {"name": "injection_protection", "value": sum(security_tests), "target": len(security_tests), "threshold": len(security_tests), "passed": success}
                ],
                "security_results": security_tests
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def test_xss_protection(self):
        """Test protection against Cross-Site Scripting (XSS)"""
        try:
            security_tests = []
            
            # Test 1: Stored XSS in account name
            xss_data = {
                "name": "<script>alert('XSS')</script>",
                "account_type": AccountType.GENERATION,
                "initial_balance": 100000.0,
                "owner_id": self.test_user_id
            }
            
            result = self.api.create_account(self.user_token, xss_data)
            security_tests.append(result["success"] is True)
            
            # Retrieve account and check if script tags are sanitized
            account = self.db.get_account_by_id(result["account_id"])
            sanitized_name = account.name
            
            security_tests.append("<script>" not in sanitized_name)
            
            # Test 2: Reflected XSS in search parameters
            search_data = {
                "query": "<img src=x onerror=alert('XSS')>",
                "owner_id": self.test_user_id
            }
            
            result = self.api.search_accounts(self.user_token, search_data)
            security_tests.append(result["success"] is True)
            
            # Check if response contains sanitized output
            result_str = json.dumps(result)
            security_tests.append("<img" not in result_str)
            
            # Test 3: DOM-based XSS in transaction description
            transaction_data = {
                "amount": 1000.0,
                "transaction_type": "deposit",
                "description": "XSS Test <div onmouseover='alert(1)'>Hover me</div>"
            }
            
            result = self.api.add_transaction(self.user_token, self.test_account_id, transaction_data)
            security_tests.append(result["success"] is True)
            
            # Retrieve transaction and check if HTML is sanitized
            transactions = self.api.get_account_transactions(self.user_token, self.test_account_id)
            transaction = transactions["transactions"][-1]
            
            security_tests.append("<div" not in transaction["description"])
            
            # Test 4: XSS in error messages
            invalid_data = {
                "name": "<script>alert('XSS')</script>",
                "account_type": "INVALID_TYPE",  # This will cause an error
                "initial_balance": 100000.0,
                "owner_id": self.test_user_id
            }
            
            result = self.api.create_account(self.user_token, invalid_data)
            security_tests.append(result["success"] is False)
            
            # Check if error message contains sanitized input
            security_tests.append("<script>" not in result["error"])
            
            # Test 5: Content Security Policy
            # This is typically tested in a browser context, but we can check if CSP headers are set
            # For this test, we'll assume the API sets CSP headers and check if the security framework has CSP configuration
            has_csp = hasattr(self.security, 'get_content_security_policy')
            
            if has_csp:
                csp = self.security.get_content_security_policy()
                security_tests.append(csp is not None and len(csp) > 0)
            else:
                # Skip this test if CSP is not implemented
                security_tests.append(True)
            
            # Calculate success
            success = all(security_tests)
            
            return {
                "success": success,
                "metrics": [
                    {"name": "xss_protection", "value": sum(security_tests), "target": len(security_tests), "threshold": len(security_tests), "passed": success}
                ],
                "security_results": security_tests
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def test_csrf_protection(self):
        """Test protection against Cross-Site Request Forgery (CSRF)"""
        try:
            security_tests = []
            
            # Test 1: CSRF token validation
            # Get CSRF token
            csrf_token = self.security.generate_csrf_token(self.test_user_id)
            security_tests.append(csrf_token is not None)
            
            # Test with valid CSRF token
            update_data = {
                "name": "CSRF Test Account",
                "csrf_token": csrf_token
            }
            
            result = self.api.update_account(self.user_token, self.test_account_id, update_data)
            security_tests.append(result["success"] is True)
            
            # Test with invalid CSRF token
            update_data = {
                "name": "CSRF Invalid Test",
                "csrf_token": "invalid_token_123"
            }
            
            result = self.api.update_account(self.user_token, self.test_account_id, update_data)
            security_tests.append(result["success"] is False)
            security_tests.append("csrf" in result["error"].lower())
            
            # Test 2: CSRF token expiration
            # Generate expired token
            expired_token = self.security.generate_csrf_token(self.test_user_id, expires_in=-3600)  # Expired 1 hour ago
            
            update_data = {
                "name": "CSRF Expired Test",
                "csrf_token": expired_token
            }
            
            result = self.api.update_account(self.user_token, self.test_account_id, update_data)
            security_tests.append(result["success"] is False)
            security_tests.append("expired" in result["error"].lower())
            
            # Test 3: CSRF token per-session uniqueness
            # Generate tokens for different sessions
            token1 = self.security.generate_csrf_token(self.test_user_id)
            token2 = self.security.generate_csrf_token(self.admin_user_id)
            
            security_tests.append(token1 != token2)
            
            # Test 4: CSRF protection for state-changing operations
            # Test if GET requests don't require CSRF token
            result = self.api.get_account(self.user_token, self.test_account_id)
            security_tests.append(result["success"] is True)
            
            # Test if POST/PUT/DELETE requests require CSRF token
            # Create account without CSRF token
            account_data = {
                "name": "CSRF Protection Test",
                "account_type": AccountType.GENERATION,
                "initial_balance": 100000.0,
                "owner_id": self.test_user_id
                # No CSRF token
            }
            
            result = self.api.create_account(self.user_token, account_data)
            security_tests.append(result["success"] is False)
            security_tests.append("csrf" in result["error"].lower())
            
            # Test 5: SameSite cookie attribute
            # This is typically tested in a browser context, but we can check if the security framework sets SameSite attribute
            has_same_site = hasattr(self.security, 'get_cookie_settings')
            
            if has_same_site:
                cookie_settings = self.security.get_cookie_settings()
                security_tests.append(cookie_settings is not None)
                security_tests.append("samesite" in cookie_settings.lower())
            else:
                # Skip these tests if SameSite is not implemented
                security_tests.append(True)
                security_tests.append(True)
            
            # Calculate success
            success = all(security_tests)
            
            return {
                "success": success,
                "metrics": [
                    {"name": "csrf_protection", "value": sum(security_tests), "target": len(security_tests), "threshold": len(security_tests), "passed": success}
                ],
                "security_results": security_tests
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def run_all_tests(self):
        """Run all security vulnerability tests"""
        test_funcs = {
            "authentication_vulnerability": self.test_authentication_vulnerability,
            "authorization_vulnerability": self.test_authorization_vulnerability,
            "injection_attack": self.test_injection_attack,
            "xss_protection": self.test_xss_protection,
            "csrf_protection": self.test_csrf_protection
        }
        
        results = self.framework.run_test_suite("security_vulnerability", test_funcs, "security")
        return results


# Run tests if executed directly
if __name__ == "__main__":
    tests = SecurityVulnerabilityTests()
    results = tests.run_all_tests()
    
    # Generate and print report
    framework = tests.framework
    report = framework.generate_test_report("text")
    print(report["text_report"])
    
    # Export results
    framework.export_test_results("security_vulnerability_test_results.json")
    
    # Clean up
    framework.cleanup()

